package identity_test

import (
	"encoding/hex"
	"math/big"
	"testing"

	"github.com/rarimo/ldif-sdk/ldif"
	identity "github.com/rarimo/rarime-mobile-identity-sdk"
	"github.com/stretchr/testify/assert"
)

func TestLightSignatureWithPubSignals(t *testing.T) {
	privateKey := "18cadcf91ee2bd025ed4581a87906911631faba366b9e61e1c70f80d89f75de6"
	pubSignals := []string{"0x20925303098627062266630214635967906856225360340756326562498326001746719100911", "0x303030303030", "303030303030", "0", "0", "0", "5589842", "0", "0", "304358862882731539112827930982999386691702727710421481944329166126417129570", "303030303030", "303030303030", "39", "0", "0", "1", "0", "52983525027888", "52983525027888", "52983525027888", "5298352502788", "0"}

	signature, err := identity.SignPubSignalsWithSecp256k1(privateKey, pubSignals)
	if err != nil {
		t.Fatalf("signature is incorrect %s", err)
	}

	t.Log(signature)
}

func TestLightSignature(t *testing.T) {
	privateKey := "18cadcf91ee2bd025ed4581a87906911631faba366b9e61e1c70f80d89f75de6"
	message := "041a2814efbd3b77d254aeed92f768616a7f66c4fee65f3de152b4fdcb62e1f082faaa09bb88ff9e660397086031cb66aef53735f1d88f7eb2b682cbdd20b4900b"

	signature, err := identity.SignMessageWithSecp256k1(privateKey, message)
	if err != nil {
		t.Fatalf("signature is incorrect %s", err)
	}

	t.Log(signature)
}

func TestBytesArrayToBits(t *testing.T) {
	bytes := []byte{0x01, 0x02, 0x03}

	bits := identity.ByteArrayToBits(bytes)

	assert.Equal(t, []int64{0, 0, 0, 0, 0, 0, 0, 1}, bits[:8], "First byte")
	assert.Equal(t, []int64{0, 0, 0, 0, 0, 0, 1, 0}, bits[8:16], "Second byte")
	assert.Equal(t, []int64{0, 0, 0, 0, 0, 0, 1, 1}, bits[16:24], "Third byte")
}

func TestSmartChunking2(t *testing.T) {
	bytes, _ := hex.DecodeString("48656c6c6f20776f726c64")

	bits := identity.ByteArrayToBits(bytes)

	res := identity.SmartChunking2(bits, 1)

	t.Log(res)
}

func TestSmartChunking(t *testing.T) {
	bi, ok := new(big.Int).SetString("c8052f9d1e0dfe98ed2d4b39a57f536085f30a3db3b2d3b867af4ace8b061bfa6f9afa670278fb4fb20d8b974f550dae40fabb3627d341691b2d7aee46d379d5a5e571aab21d94ca48e40fe2adeb57effeef84ce112fc1d2dfc62e1a272a12e9d6545d72efefac7f8f3f1a6227928efe49fbb9642ad1149e7f7a9b46cc60c2983b3a47dd82080e5512a34aa4a84d5d9e4acfd117c772980c2caa106c2b65e24d2b1a4617175fbc6f3d60d5e6aa15a21e2db64afafa64352a2ee89aaea4646aa3d3fd8dd2a9a6491182831e9a8ee7f365e3cea5309b6940d1805cb581854898a6063403c2b11484d02e12a97711645667034bfee7c028c5bfd22ed84c9972cebb9e9c0a8b53a940148972af7a5ed140028fe6649f33b0a8eb20ac6918f15769f7dcf449d0a8d8035cc4075aadfdc70ad60450e42c71d1776a866221ec65501df37f4d5709d2fdba10669e57d2a25eb7e110a676313a8f134c1c92bf438ba3131b30c37e516d82231a485797ae0b9f7943f4892c7cc4e8c221166011a730b5ac5c261c8adbe9bbcdcd711c83a9bac739f2c5e664ceca50df53f51cf9409aed874debf4e56326903fba5bbfb442dcae851f89aed4b5c063e7977928f513c2185c40f5d687ecef3f7aec282bfd1af4cc0e9c5a220f83a98e088d74716dba88f07ab5c320af1c68ffac6c4fd9a3f432c61429af44146052f2836ae8310a53235451b7", 16)
	if !ok {
		t.Error("Error parsing big int")
	}

	res := identity.SmartChunking(bi, 64)

	t.Log(res)

	assert.Equal(t, 64, len(res), "Number of chunks")
}

func TestHashKey(t *testing.T) {
	bi, ok := new(big.Int).SetString("750226886442114898214525980900489236852416290230819363092609168845181706221966184805429558191323116573225223660792107157694218429751173890382615338007225628828221244223759109025773693414571110357932027140364245333574160661587142753596786549828168588092197095676262482699469494080006669101294407754477824183528200201545907285617627175462769170281403074026986000794531686270836082765689601947520869764355207506118350045626442019452495483682355355617968192099383053697333510728720988613569475708453805367076685495371238711565423705304356910224161922251570888153579140437656767198765486953994558457598873637277662724029412769349453017252324266970667065451241479923226220126172244105851538679775922469046729172834872106109432314858263014492520625555737068394341236249040229894047831920031258031692752884342344993352476332696096248192249297947575097493481773433364130826550230156115966306752515149193449449678189944732916570915456846748319963404620438544811107467171074559118838774321346479854990238492889105084449328968206186710599251420963924950486861199197406431210653675492229986054618050891399009188576769103092731173024227571167570549368977874296722960978845848498876779096651593414755319660971212577411840918794782450096627376783547", 10)
	if !ok {
		t.Error("Error parsing big int")
	}

	result, err := identity.HashKey(bi.Bytes())
	if err != nil {
		t.Error(err)
	}

	t.Log(result.Text(10))
}

func TestLdif(t *testing.T) {
	value, err := ldif.FromFile("assets/ldif.ldif")
	if err != nil {
		t.Error(err)
	}

	pems := value.ToPem()

	var pem string
	for _, p := range pems {
		pem += p
	}

	t.Log(pem)
}
